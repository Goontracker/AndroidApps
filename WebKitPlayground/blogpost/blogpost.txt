

Android WebKit Performance

This article discusses the use of JavaScript and HTML5 to author mobile apps, and provides hands-on examples and performance tests for Android.

Which mechanism is the fastest for making calls from JavaScript to Java? How can Native UI components be controlled from JavaScript? How does the HTML5 Canvas compare to drawing on a Native Android Canvas?

Introduction

Authoring mobile apps in JavaScript is compelling for several reasons:

* Portability
* High-level language
* Fast turn-around (Live coding)

Portability 

JavaScript is available on all modern mobile platforms (Android, iOS, Firefox OS, Windows Phone, etc). An app can run JavaScript code in a WebView and make full use of HTML5 functionality, and as needed invoke native code using mechanisms such as JavaScriptInterface on Android. 

Furthermore, apps can run JavaScript inside a hidden WebView, and call platform code to display a fully Native UI. Cross-platform development tools like MoSync SDK and Cordova provide such capabilities out of the box. 

Thus, using JavaScript can make your apps easier to port and to maintain, while still providing the possibility to access unique native features of each target platform.

You can also target desktop apps for Windows, OS X, and Linux can be made, using framworks such as node-wekbit.

High-level language

JavaScript is a high-level dynamic language, that enables the use of powerful programming techniques such as higher-order functions http://en.wikipedia.org/wiki/Higher-order_function, closures and prototyp objects. While developers make disagree on the suitability of JavaScript and other dynamic languages for large applications, it is a fact that JavaScript is widely adopted and appreciated by its users.

Fast-turn around

With a dynamic language comes the prospect of speeding up the development cycle. It is a well established pattern to edit code and then reload on a web browser to quickly see the result. For mobile development, tools such as MoSync Reload provide similar capabilities. 

There is also the possibility of updating a program while running, using technologies similar to a REPL or Smalltalk Workspace. The JavaScript Workbench in reload is an example of the use of this for mobile development.

Furthermore, there is the prospect of "live coding", where the program is updated while edited, and can be edited in real-time while running. The MoLive project by Paolo Boschini is an example of live coding for mobile devices.

Android WebView

Android provides the WebView class, which encapsulates the WebKit browser and a JavaScript engine as a widget. You can even run JavaScript in a hidden WebView, and this is a handy way to script apps, or write the entire application logic in JavaScript.

You can use the WebView to display the UI in HTML/CSS, or use bindings to Java to call methods to create a Native UI. This provides developers with a toolbox of flexible solutions.

Now, the question is, how fast is JavaScript running in a WebView? And what is the performance when it comes to calling into the natgive layer from JavaScript?

WebView Performance

To study the performance of running JavaScript in a WebView, we will look at a hands on example. The Android app WekKit Playground, demonstrates the programming techniques involved, and also provides performance tests. The full source code of the app is found on GitHub, and there is also an APK-file you can download and install.

Tests

The following JavaScript to Java calling mechanisms are tested by the app:

* One way calls: Performance of calling from JavaScript to Java using the JavaScriptInterface binding mechanism on Android.
* Two way calls: Performance of calling from JavaScript to Java and back to JavaScript. Calling from Java to JavaScript is done by invoking a "javascript:" URL on the WebView.
* Prompt hook: There are various alternatives to using JavaScriptInterface, but they are less elegant. One such mecanism is the hook provided be the WebView class for the JavaScript prompt function. This is tested to illustrate an additional mechanism. Also in this case two way calls are used. Thus the results should be compared to the two way JavaScriptInterface test.

The app also contains interactive tests of painting on a canvas:

* HTML5 Canvas: Performance test of painting on an HTML5 canvas.
* Android Canvas controlled via JavaScript: Test of painting on an Android canvas where events are routed though JavaScript and drawing is made using JavsScript calls to Java.
* Android Canvas in Java: Painting on an Android canvas natively from Java (no JavaScript used).

The interactive tests work as follows. A full screen canavs is displayed. On the first touch down event, a counter is set to zero and a time stamp is made. On subsequent touch drag events, the counter is incremented by one for each event, and when the number of touch strokes is 100, and the time from the touch down event is measured.

To run the canvas tests, touch the screen with a finger, and then rapidly move the finger back and forth, painting with the finger. When the test is done, the result screen is presented.

While this is not an ideal test, since it depends on how fast the tester moves the finger, it gives a hint at the performance of the different canvas options.

Now, it is time to see how the tests score. Which canvas is the fastest?

Test Results

The test app was run on a Nexus 7, running Android 4.2.2.

The following are the results of the interactive tests:

* HTML5 Canvas Test: Around 2000 ms
* Android Canvas JS Test: Around 3600 ms
* Android Canvas Native Test: Adround 2800 ms

The following are the results of the interactive tests:

* HTML5 Canvas Test: Around 2000 ms
* Android Canvas JS Test: Around 3600 ms
* Android Canvas Native Test: Adround 2800 ms


Conclusion


Note that the use of JavaScript to receive events from and draw on a native canvas serves as an illustration of how the use of JavaScript can be extended beyond its traditional role as a web browser language.




CV

skills PhoneGap/Cordova (implemented in MoSync)

